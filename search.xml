<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础</title>
      <link href="/2021/11/14/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/14/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><h2 id="基础数据类型-与-引用数据类型"><a href="#基础数据类型-与-引用数据类型" class="headerlink" title="基础数据类型 与 引用数据类型"></a>基础数据类型 与 引用数据类型</h2><ul><li><p>基础数据类型</p></li><li><p>引用数据类型</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;八种基本数据类型     默认值 为 0   0.f  0.0   falsebyte a &#x3D; 1;          1 2 4 8short b &#x3D; 2;int c &#x3D; 3;long d &#x3D; 4;boolean e &#x3D; false;char f &#x3D; &#39;6&#39;;float g &#x3D; 7.f;double h &#x3D; 8.00;&#x2F;&#x2F;都是 对象 默认值为 nullInteger q &#x3D; 11;Double de &#x3D; 23.00;BigDecimal bd &#x3D; new BigDecimal(&quot;123&quot;);&#x2F;&#x2F;何为引用数据类型   dog 即为引用数据类型   objects即为引用数据类型Dog dog &#x3D; new Dog();  ArrayList&lt;Object&gt; objects &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>String 特殊</p><pre class="line-numbers language-none"><code class="language-none">1.String 是一个对象    即默认值 为 null2.String 被 final 修饰的类   又称为字符串常量3.  String sdfa &#x3D; &quot;123&quot;;    String sfsd &#x3D; new String(&quot;sfsd&quot;);  第一种创建字符串 是在字符串常量池种创建对象  第二种是先检测 字符串常量池中有没有“sfsd”对象，没有就先在字符串常量池中创建 然后再在堆上创建对象   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JVM为了提高性能和减少内存的开销，所以在实例化字符串的时候使用字符串常量池进行优化。</p></li><li><p>new String(“abc”) 创建了几个对象？</p></li></ul><p>这可能就是想考你对字符串常量池的理解，我一般回答是一个或者两个对象。</p><p>如果之前”abc”字符串没有使用过，毫无疑问是创建两个对象，<strong>堆中创建了一个String对象，字符串常量池创建了一个</strong>，一共两个。</p><p>如果之前已经使用过了”abc”字符串，则不会再在字符串常量池创建对象，而是从字符串常量缓冲区中获取，只会在堆中创建一个String对象。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>基础类型 存放在 栈中</p><p>对象存放在堆中，在栈中用一个变量指向对象  （栈中存放 对象在堆中的地址）</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>向上转型 / 向下转型</li><li>接口回调</li></ul><p>继承的多态  可以用父类变量来接收子类对象 （向上转型）</p><ol><li><p>方法参数上使用 父类变量 当形参   ，真实调用时候就可以 传子类 当作实参</p></li><li><p>父类想转子类 怎么转 ？使用强转    Dog dog = (Dog) Animal();</p><p>强转之前先使用 instanceof 判断一下 </p></li></ol><pre class="line-numbers language-none"><code class="language-none">if ( people instanceof Humanity)&#123;&#x2F;&#x2F;进行强转    System.out.println(&quot;是Humanity子类&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接口的多态 一个接口可以有多个实现</p><p>​    1.用接口来接收 实现类  </p><p>​    2.引申一下 函数式接口编程（用匿名实现类的方式创建一个实现类 对象 赋值给接口）</p><p>​    在简化使用lemda表达式的方式。</p><p>​    3.用接口当作参数，可以讲接口的具体实现交给 方法调用者，有方法调用者 创建一个接口实现类 传给 这个接口</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;父类public abstract class Humanity &#123;    abstract void sayHello();&#125;&#x2F;&#x2F;接口public interface Say &#123;    void sayHello();&#125;&#x2F;&#x2F;子类public class People extends Humanity &#123;    private Say say;    public People(Say say) &#123;        this.say &#x3D; say;    &#125;    &#x2F;&#x2F;重写父类方法    @Override    public void sayHello() &#123;        this.getSay().sayHello();    &#125;    public Say getSay() &#123;        return say;    &#125;    public void setSay(Say say) &#123;        this.say &#x3D; say;    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 简化 函数接口编程  （匿名类   接口回调）        People people &#x3D; new People(()-&gt;&#123;            &#x2F;&#x2F;do something            System.out.println(&quot;111111111111111111111111111111&quot;);        &#125;);        &#x2F;&#x2F; 匿名类   接口回调        People people1 &#x3D; new People(new Say() &#123;            @Override            public void sayHello() &#123;                System.out.println(&quot;222222222222222&quot;);            &#125;        &#125;);        &#x2F;&#x2F; 向上转型        Humanity people3 &#x3D; new People(() -&gt; &#123;System.out.println(&quot;3333333&quot;);&#125;);        people3.sayHello();        &#x2F;&#x2F;        Humanity humanity &#x3D; new Humanity() &#123;            @Override            void sayHello() &#123;                System.out.println(&quot;44444444444&quot;);            &#125;        &#125;;        humanity.sayHello();        people.sayHello();        people1.sayHello();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h1><ul><li>继承    is-a</li><li>组合    has-a</li><li>委托  （方法的转发、方法的代理）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础</title>
      <link href="/2021/11/03/mysql%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/03/mysql%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul><li>索引</li><li>mysql索引分类</li></ul><pre class="line-numbers language-none"><code class="language-none">一种排好序的快速查找的数据结构单值索引   可以重复唯一索引   不能重复 可以为null复合索引   多个单值索引主键索引   不能重复，不能为null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>create (unique) index  indexName on mytable (columname)</p><ul><li>mysql 索引结构</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>适合创建索引</li></ul><pre class="line-numbers language-none"><code class="language-none">主键自动创建唯一索引频繁作为查询条件的字符应该创建索引查询中与其他表关联的字段，外键字段应该建立索引频繁更新的字段不适合创建索引where 条件中用不到的字段不创建索引组合索引排序字段 创建索引大大提高排序速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引的选择性是指索引列中不同值的数目与表中记录数的比</p><p>该值越接近1，索引效率越高</p><p>性能分析 explain</p><p>explain+sql语句</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; explain select * from user;id:执行顺序 id越大优先级最高 越先执行select_type:查询类型 simple 单表  primaky 主表 sub_query 子查询  derived虚表 type:访问类型 system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL +----+-------------+-------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------+|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    4 | NULL  |+----+-------------+-------+------+---------------+------+---------+------+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单表索引优化</p><p>1.索引，  最左匹配原则   索引是从左到右按顺序匹配</p><p>如果使用 &gt; ,&lt; ,!= 条件进行筛选 ，那么这个字段及这个字段右边的字段就不走索引，</p><p>范围查询不走索引</p><p>2.双表  索引优化</p><p>a left join b  A表左连接B表</p><p>查询A的全部，搜索B表中满足条件的去 连接A表中的数据</p><p>所以 索引应该建立在 b 表中 才会生效。如果建立在a表中，因为是a左连接b ，首先是先要查询出a的全部，不走索引，条件是用来筛选B表的</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的常规命令</title>
      <link href="/2021/10/21/Linux%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/10/21/Linux%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="12312312"><a href="#12312312" class="headerlink" title="12312312"></a>12312312</h3><ul><li>磁盘空间大小</li></ul><pre class="line-numbers language-none"><code class="language-none">dfdf 以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。df -hl：查看磁盘剩余空间df -h：查看每个根路径的分区大小du -sh [目录名]：返回该目录的大小du -sm [文件夹]：返回该文件夹总M数du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\17292\AppData\Roaming\Typora\typora-user-images\image-20211011152719555.png" alt="image-20211011152719555"></p><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><pre class="line-numbers language-none"><code class="language-none">显示文件使用空间：du例如，以 M 为单位显示内存使用情况：free -mfree -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vim编辑</p><pre class="line-numbers language-none"><code class="language-none">:q! 退出不保存:wq! 保存退出从开头搜索在命令模式下，输入&#x2F;你要查找的字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>删除</p><pre class="line-numbers language-none"><code class="language-none">rm -f + 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf +文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查进程</li></ul><pre class="line-numbers language-none"><code class="language-none">ps -ef|grep rediskill -9 pid <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>后台并 重定向日志</li></ul><pre class="line-numbers language-none"><code class="language-none">nohup java -jar xxxx &gt; log.txt &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>workdetail</title>
      <link href="/2021/10/21/workdetail/"/>
      <url>/2021/10/21/workdetail/</url>
      
        <content type="html"><![CDATA[<h2 id="配合-策略模式-使用-getBeansOfType"><a href="#配合-策略模式-使用-getBeansOfType" class="headerlink" title="配合 策略模式 使用 getBeansOfType"></a>配合 策略模式 使用 getBeansOfType</h2><p>applicationContext.getBeansOfType<br><a href="https://juejin.cn/post/7023536216138055716">https://juejin.cn/post/7023536216138055716</a><br><a href="https://juejin.cn/post/6963625016709611534">https://juejin.cn/post/6963625016709611534</a></p><p>工厂</p><pre class="line-numbers language-none"><code class="language-none">@Componentpublic class StrategyUseService implements ApplicationContextAware&#123;      private Map&lt;FileTypeResolveEnum, IFileStrategy&gt; iFileStrategyMap &#x3D; new ConcurrentHashMap&lt;&gt;();    public void resolveFile(FileTypeResolveEnum fileTypeResolveEnum, Object objectParam) &#123;        IFileStrategy iFileStrategy &#x3D; iFileStrategyMap.get(fileTypeResolveEnum);        if (iFileStrategy !&#x3D; null) &#123;            iFileStrategy.resolve(objectParam);        &#125;    &#125;    &#x2F;&#x2F;把不同策略放到map    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        Map&lt;String, IFileStrategy&gt; tmepMap &#x3D; applicationContext.getBeansOfType(IFileStrategy.class);        tmepMap.values().forEach(strategyService -&gt; iFileStrategyMap.put(strategyService.gainFileType(), strategyService));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>策略模式 将 接口作为 类的实例变量 ，利用接口的多态 ，在运行是给接口变量赋值 接口实现类，从而达到在运行中改变行为</p><p>（运行中改变方法）</p><p><img src="workdetail%5CDuck.png" alt="Duck"></p><p><img src="Duck.png" alt="Duck"></p><pre class="line-numbers language-none"><code class="language-none">public class Test &#123;    public static void main(String[] args) &#123;        BlackDuck blackDuck &#x3D; new BlackDuck();        blackDuck.setFly(()-&gt;&#123;            System.out.println(&quot;黑鸭子飞行&quot;);        &#125;);        blackDuck.setQuack(()-&gt;&#123;            System.out.println(&quot;黑鸭子叫&quot;);        &#125;);        blackDuck.display();        blackDuck.performFly();        blackDuck.performFly();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="delete-中-子查询-同一张表"><a href="#delete-中-子查询-同一张表" class="headerlink" title="delete 中 子查询 同一张表"></a>delete 中 子查询 同一张表</h2><pre class="line-numbers language-none"><code class="language-none">DELETE FROMbase_channel WHEREid IN (SELECT n.id FROM(SELECTb1.id FROMbase_channel b1,base_channel b2 WHEREb1.id !&#x3D; b2.id AND b1.&#96;name&#96; &#x3D; b2.NAME AND b1.gq_id &#x3D; b2.gq_id ) as n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>in 后面的子查询不能带where条件，带where条件的必须使用别名</p><pre class="line-numbers language-none"><code class="language-none">delete from table1 where id in (select id from table1 where id &gt; 30);[Err] 1093 - You can’t specify target table &#39;table1 ’ for update in FROM clausedelete from table1 where id in (select n.id from (select id from table1 where id &gt; 30) as n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- ttoc --><h3 id="xml-模糊查询"><a href="#xml-模糊查询" class="headerlink" title="xml   模糊查询"></a>xml   模糊查询</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 水功能区代码  模糊--&gt;&lt;if test&#x3D;&quot;wfzCdMh !&#x3D; null and wfzCdMh !&#x3D; &#39;&#39;&quot;&gt;  AND (info.WFZ_CD like CONCAT(&#39;%&#39;, #&#123;wfzCdMh&#125;,&#39;%&#39;) or info.WFZ_LV1_NM like CONCAT(&#39;%&#39;, #&#123;wfzCdMh&#125;,&#39;%&#39;)  or   info.WFZ_NM like CONCAT(&#39;%&#39;, #&#123;wfzCdMh&#125;,&#39;%&#39;) )&lt;&#x2F;if&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置jar-入口类"><a href="#配置jar-入口类" class="headerlink" title="配置jar 入口类"></a>配置jar 入口类</h2><p> <strong><mainClass>com.example.generator.GoMain</mainClass></strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;             &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;             &lt;version&gt;2.3.7.RELEASE&lt;&#x2F;version&gt;             &lt;configuration&gt;                 &lt;mainClass&gt;com.example.generator.GoMain&lt;&#x2F;mainClass&gt;             &lt;&#x2F;configuration&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;id&gt;repackage&lt;&#x2F;id&gt;                     &lt;goals&gt;                         &lt;goal&gt;repackage&lt;&#x2F;goal&gt;                     &lt;&#x2F;goals&gt;                 &lt;&#x2F;execution&gt;             &lt;&#x2F;executions&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java -jar jar包名  main函数参数</p><pre class="line-numbers language-none"><code class="language-none">java -classpath ****.jar ****.****.className [args]“****.****”表示“包名”；“className”表示“类名”；“[args]”表示传入的参数；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>*ReflectTest.class.getResourceAsStream(String path)：</p><p> <em>默认则是从ClassPath根下获取，path不能以’/‘开头，最终是由ClassLoader获取资源。</em></p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="装饰者模式"></p><p><img src="workdetail/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="装饰者模式"></p><p>被装饰者组件：HanGroundCoffee 手磨咖啡  Espresso  浓缩咖啡</p><p>共同超类: Beverage 饮料抽象类</p><p>抽象装饰者类：继承  Beverage 饮料抽象类</p><p>装饰者类: Mocah 摩卡  采用 （委托） （ 在cost方法中 用自己的价格在加上 beverage.cost() 价格）</p><pre class="line-numbers language-none"><code class="language-none">用摩卡 装饰 浓缩咖啡 Beverage beverage &#x3D; new Espresso(); System.out.println(beverage.getDescription() + &quot; $&quot; + beverage.cost());&#x2F;&#x2F;浓缩咖啡 $1.99  &#x2F;&#x2F;用摩卡装饰 浓缩咖啡 Mocha mocha &#x3D; new Mocha(beverage); System.out.println(mocha.getDescription()+&quot;$&quot;+mocha.cost());  &#x2F;&#x2F;浓缩咖啡摩卡$5.09<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>![WeatherData]WeatherData.png)</p><p><img src="E:\工作随笔\MyNotes\myBlog\source_posts\workdetail\WeatherData.png" alt="WeatherData"></p><p>主题接口: 三个方法 注册 通知 注销</p><p>观察者接口： 一个方法  接收通知</p><hr><p>天气数据类WeatherData实现 主题Subject接口  并让一个观察者list集合作为自己的实例变量observers，并实现 接口中的三个方法 注册 通知 注销</p><p>注册方法（利用多态） 添加 观察者接口实现类 Displayboard对象到  观察者list集合</p><p>并在通知方法中 调用观察者接口 的update()方法</p><p>观察者实现观察者接口，实现update()方法指定被通知 以后的行为。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>案例：比萨店 生成 比萨</p><p>1.书写一个类专门用来生成对象，进行解构，将对象的创建交给方法 代替new 关键字 来创建对象</p><p><img src="CheesePizza.png" alt="CheesePizza"></p><p><img src="workdetail/CheesePizza.png" alt="CheesePizza"></p><p>SimplePizza 简单工厂 ：负责生成Pizza</p><p>PizzaStore 比萨商店 ，加上一个SimplePizza的引用给变量 factory,并在构造方法中给factory赋值。并在orderPizza方法中调用 </p><p>factory.createPizza() 方法来创建 Pizza 对象。</p><pre class="line-numbers language-none"><code class="language-none">public class Test &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个工厂        SimplePizza cheese &#x3D; new SimplePizza();        PizzaStore pizzaStore &#x3D; new PizzaStore(cheese);        pizzaStore.orderPizza(&quot;cheese&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>案例升级：加州 和 芝加哥 想要加盟比萨店，加州比萨店生产加州口味的比萨，芝加哥比萨店生产芝加哥风味比萨。</p><p>在推广 使用简单工厂模式时，你会发现 加盟店的确采用你的工厂创建比萨，但是其他部分开始采用他们自创的流程， 烘烤的做法有点差异，切片方式不同，使用其他厂商的盒子…</p><p>你想创建一种方式，将 加盟店这个行为和创建比萨捆绑在一起，同时又保持一定的弹性，允许各自加盟商使用自己自创的流程 加工比萨。</p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/_config.yml">https://github.com/blinkfox/hexo-theme-matery/blob/develop/_config.yml</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的sql语法</title>
      <link href="/2021/10/21/mysql%E7%9A%84sql%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/10/21/mysql%E7%9A%84sql%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>语法 case when用法</li></ul><pre class="line-numbers language-none"><code class="language-none">简单函数   类似于 switch 函数   SELECT*,CASE compareWHEN &#39;L&#39; THEN &#39;大于&#39;WHEN &#39;LE&#39; THEN &#39;大于等于&#39;ELSE &#39;无&#39;END &#39;com&#39;FROMbase_warn_config搜索函数  SELECT*,CASE WHEN val&lt;10 THEN &#39;大于&#39;WHEN val&lt;60 THEN &#39;大于等于&#39;WHEN val&gt;160 THEN &#39;大于等于&#39;ELSE &#39;无&#39;END &#39;com&#39;FROMbase_warn_config简单函数CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END搜索函数CASE WHEN [expr] THEN [result1]…ELSE [default] END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间函数  DATE_ADD(date,INTERVAL expr unit) </li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 得到当前时间增加1个小时的结果select date_add(now(),interval 1 hour)&#x2F;&#x2F; 得到当前时间增加1天的结果select date_add(now(),interval 1 day)&#x2F;&#x2F; 得到当前时间减少72个小时的结果select date_add(now(),interval -72 hour)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用转义字符把”&gt;“和”&lt;”替换掉，就没有问题了。<br>mapper文件示例代码:</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;if test&#x3D;&quot;startTime !&#x3D; null &quot;&gt;    AND order_date &gt;&#x3D; #&#123;startTime,jdbcType&#x3D;DATE&#125; &lt;&#x2F;if&gt;&lt;if test&#x3D;&quot;endTime !&#x3D; null &quot;&gt;    AND order_date &lt;&#x3D; #&#123;endTime,jdbcType&#x3D;DATE&#125; &lt;&#x2F;if&gt;123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法一：使用特殊转义字符例如，&gt;&#x3D;开始日期 并且&lt;&#x3D;结束日期&gt;  &gt;  大于号 &lt;  &lt;  小于号     &lt;if test&#x3D;&quot;searchTimeBegin !&#x3D; null and searchTimeBegin !&#x3D; &#39;&#39;&quot;&gt;       AND tcci.consume_time &gt;&#x3D; CONCAT(#&#123;searchTimeBegin&#125;,&#39; 00:00:00&#39;)   &lt;&#x2F;if&gt;   &lt;if test&#x3D;&quot;searchTimeEnd !&#x3D; null and searchTimeEnd !&#x3D; &#39;&#39;&quot;&gt;       AND tcci.consume_time &lt;&#x3D; CONCAT(#&#123;searchTimeEnd&#125;,&#39; 23:59:59&#39;)   &lt;&#x2F;if&gt;   方法二：使用&lt;![CDATA[ ]]&gt;符号这里面的内容将不被解析    &lt;if test&#x3D;&quot;beginTime!&#x3D;null&quot;&gt;      AND DATE (os.show_start_time) &gt;&#x3D; DATE(#&#123;beginTime&#125;)    &lt;&#x2F;if&gt;    &lt;if test&#x3D;&quot;endTime!&#x3D;null&quot;&gt;      AND DATE (os.show_start_time) &lt;![CDATA[&lt;&#x3D;]]&gt; DATE(#&#123;endTime&#125;)    &lt;&#x2F;if&gt;在mybatis中&lt;&#x3D;不能使用，需要使用上面任意一种方法转义，但是&gt;&#x3D;可以使用！原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;n950814abc&#x2F;article&#x2F;details&#x2F;83182239<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>load data 导入文件</li></ul><pre class="line-numbers language-none"><code class="language-none"> &lt;select id&#x3D;&quot;insertText&quot; parameterType&#x3D;&quot;java.lang.String&quot; &gt;            LOAD DATA INFILE #&#123;fileUrl&#125; INTO TABLE &#96;user&#96; CHARACTER            SET utf8            FIELDS TERMINATED BY &#39;,&#39;            OPTIONALLY ENCLOSED BY &#39;&#39;            LINES TERMINATED BY &#39;\n&#39;            (id, username, password)    &lt;&#x2F;select&gt;            load data local infile &#39;D:&#x2F;my_user_info.txt&#39; into table user_info    CHARACTER SET utf8 -- 可选，避免中文乱码问题    FIELDS TERMINATED BY &#39;||&#39; -- 字段分隔符，每个字段(列)以什么字符分隔，默认是 \tOPTIONALLY ENCLOSED BY &#39;&#39; -- 文本限定符，每个字段被什么字符包围，默认是空字符    LINES TERMINATED BY &#39;\n&#39; -- 记录分隔符，如字段本身也含\n，那么应先去除，否则load data 会误将其视作另一行记录进行导入    (id, name, age, address, create_date) -- 每一行文本按顺序对应的表字段，建议不要省略————————————————。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_29308413&#x2F;article&#x2F;details&#x2F;109390444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>mybatis xml 文件关键标签用法</li><li>trim 标签</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt; trim&gt;标签&lt; trim &gt; : 是一个格式化的标记，可以完成set或者是where标记的功能。示例1：　　　select * from user 　　&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixoverride&#x3D;&quot;AND |OR&quot;&gt;　　　　&lt;if test&#x3D;&quot;name !&#x3D; null and name.length()&gt;0&quot;&gt; AND name&#x3D;#&#123;name&#125;&lt;&#x2F;if&gt;　　　　&lt;if test&#x3D;&quot;age !&#x3D; null and age.length()&gt;0&quot;&gt; AND age&#x3D;#&#123;age&#125;&lt;&#x2F;if&gt;　　&lt;&#x2F;trim&gt;假如说name和age的值都不为null的话打印的SQL为：select * from user where name &#x3D; ‘xx’ and age &#x3D; ‘xx’在where的后面是不存在第一个and的，上面两个属性的意思如下：　　prefix：前缀　　　　　　　　prefixoverride：去掉第一个and或者是or示例2：　　update user　　&lt;trim prefix&#x3D;&quot;set&quot; suffixoverride&#x3D;&quot;,&quot; suffix&#x3D;&quot; where id &#x3D; #&#123;id&#125; &quot;&gt;　　　　&lt;if test&#x3D;&quot;name !&#x3D; null and name.length()&gt;0&quot;&gt; name&#x3D;#&#123;name&#125; , &lt;&#x2F;if&gt;　　　　&lt;if test&#x3D;&quot;age!&#x3D; null and age.length()&gt;0&quot;&gt; age&#x3D;#&#123;age&#125; ,  &lt;&#x2F;if&gt;　　&lt;&#x2F;trim&gt;假如说name和age的值都不为null的话打印的SQL为：update user set name&#x3D;‘xx’ , age&#x3D;‘xx’ where id&#x3D;‘x’在age&#x3D;&#39;xx’的后面不存在逗号，而且自动加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义如上：　　 suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）　 　suffix：后缀<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>foreach 标签</li></ul><pre class="line-numbers language-none"><code class="language-none">foreach 标签foreach标签经常用于遍历集合，构建in条件语句或者批量操作语句。foreach：collection：指定要遍历的集合（list类型的参数会特殊处理封装在map中，map的key就叫listitem：将当前遍历出的元素赋值给指定的变量separator：每个元素之间的分隔符open：遍历出所有结果拼接一个开始的字符串close：遍历出所有结果拼接一个结束的字符串index：遍历list的时候，index就是索引，item就是当前值      遍历map的时候，index就是map的key，item就是map[key]的值#&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素&lt;select id&#x3D;&quot;getEmpsByConditionForeach&quot; resultType&#x3D;&quot;com.caochenlei.mybatis.crud.Employee&quot;&gt;select * from employee&lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;item_id&quot; separator&#x3D;&quot;,&quot; open&#x3D;&quot;where id in(&quot; close&#x3D;&quot;)&quot;&gt;#&#123;item_id&#125;&lt;&#x2F;foreach&gt;&lt;&#x2F;select&gt;&lt;insert id&#x3D;&quot;addEmps&quot;&gt;insert into employee (id,last_name,email,gender,dep_id) values&lt;foreach collection&#x3D;&quot;emps&quot; item&#x3D;&quot;emp&quot; separator&#x3D;&quot;,&quot;&gt;(#&#123;emp.id&#125;,#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dep.depId&#125;)&lt;&#x2F;foreach&gt;&lt;&#x2F;insert&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>触发器</li></ul><pre class="line-numbers language-none"><code class="language-none">DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；2.OLD 中的值全都是只读的，不能更新BEGINDELETE FROM yr_rvdync_b  WHERE RVSCT_CD &#x3D; old.RVSCT_CD;DELETE FROM yr_rvcrbud_b  WHERE RVSCT_CD &#x3D; old.RVSCT_CD;ENDinsert 触发器在 insert 语句执行之前或之后执行1.在 insert 触发器代码内，你可以引用一个名为 new 的虚拟表，访问被即将新增的行；BEGIN  SET new.PDO_CD &#x3D; concat( s1, s2 );END3.触发器中使用判断 不为空   IF NEW.DATA_FLAG &#x3D; &#39;update&#39; THEN  IF new.id is not null Then   END IF;4.获取第2个以逗号为分隔符之前的所有字符。 &#x2F;&#x2F;7654,7698SELECT SUBSTRING_INDEX(&#39;7654,7698,7782,7788&#39;,&#39;,&#39;,2);将分隔符逗号替换为空。                &#x2F;&#x2F;7654769877827788SELECT REPLACE(&#39;7654,7698,7782,7788&#39;,&#39;,&#39;,&#39;&#39;);获取 ‘7654,7698,7782,7788’ 字符串的长度   &#x2F;&#x2F;19SELECT LENGTH(&#39;7654,7698,7782,7788&#39;)&#x2F;&#x2F;new.id &#x3D; &quot;14,14,15,15&quot;BEGINDECLARE n INT;IF new.id is not NULL THENSET n &#x3D; 0;SELECT  LENGTH(new.id)-LENGTH(REPLACE(new.id,&#39;,&#39;,&#39;&#39;))+1 INTO n;&#x2F;&#x2F;循环IF(n&gt;0) THEN-- SUBSTRING_INDEX(new.id,&#39;,&#39;,n)-- 插入SET n &#x3D; n-1;END IF;END IF;END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> nivacat </tag>
            
            <tag> mybatis xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
